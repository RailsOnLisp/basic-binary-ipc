#+TITLE: IPC Extension for Basic Binary Packet
#+AUTHOR: Mark Cox

This library is a supporting library that provides inter process
communication facilities to the basic binary packet library.

[TABLE-OF-CONTENTS]

* Installation
This library provides a simple interface for performing inter-process
communication with ~(UNSIGNED-BYTE 8)~ communication channels.

The prerequisite systems for this extension are
- [[http://common-lisp.net/project/cffi/][~CFFI~]]
- [[https://github.com/OdonataResearchLLC/lisp-unit][Lisp Unit]] (tests only)
These libraries can be obtained using [[http://www.quicklisp.org][Quicklisp]].

Access to the operating system's networking API is performed using the
foreign function interface provided by ~CFFI~. The operating systems
that are supported are:
- [[http://www.apple.com/osx/][Apple OSX]] (Tested with version 10.7)
- [[http://www.freebsd.org][FreeBSD]] (Tested with version 9.1)
- Linux (Tested with [[http://www.debian.org][Debian]] squeeze)
- NEED-TO-IMPLEMENT [[http://windows.microsoft.com/en-US/windows/home][Microsoft Windows]] (Tested with version XP)

* Introduction
This extension provides an interface to conduct communication between
two processes. The interface is designed primarily for use within an
event loop.

The main focus of the interface is to provide an easy interface to
establishing a communication channel known as a stream. A stream has
the characteristic that it is bidirectional and full duplex channel
with a guarantee that the order in which data is read is the same as
the order it was written and that the data written is the same as the
data read.

A stream is considered to be established only when two entities,
termed [[*Stream Sockets][stream sockets]], have agreed that they want and can talk to each
other. Stream sockets can only be created in two ways, by telling a [[*Stream
 Servers][server]] to accept a connection, or by initiating a connection to a
remote server.

It is important that the process initiating the connection and the
server process waiting for connections are both using the same network
namespace. This library provides applications with the ability to
communicate using the following namespaces
- [[*IPv4][IPv4]] :: The Internet protocol version 4 namespace using the
          transmission control protocol.
- [[*Local][Local]] :: Local or Unix domain sockets for communicating between
           processes located on the same physical device. 

Once a namespace is chosen and the objects created, the application
can use a number of protocols to ascertain their state. These
protocols cover the following areas of:
- telling a server to accept incoming connections.
- provide feedback during the period where a stream is being
  established.
- send and receive data over an established stream.
- polling for events.

* Sockets
Fundamental to the interface is the notion of a socket. A socket
represents an operating system that is capable of performing
communication. 

An object representing a socket always uses operating system
resources. These resources can be released by using the ~CLOSE-SOCKET~
function.
#+begin_src lisp
(defgeneric close-socket (object))
#+end_src

There are two types of sockets that can be created, a stream server or
a stream socket. Creating these sockets is specific to the namespace
chosen by the application, but once they are created, they utilise the
protocols outlined next.

** Stream Servers
The stream server protocol represents sockets that listen for
connections from clients. A server object is not actually capable of
conducting communication. Its purpose is to allow an application to
accept incoming connections.

Accepting a new connection is performed using the ~ACCEPT-CONNECTION~
function.
#+begin_src lisp
(defgeneric accept-connection (server))
#+end_src
This function returns a new object that implements the [[*Stream Clients][stream client]]
protocol.  The ~ACCEPT-CONNECTION~ function will signal a
~NO-CONNECTION-AVAILABLE-ERROR~ condition if no client is waiting for
acknowledgment.

It should be noted that the returned stream client object is
dissociated from the server that created the connection i.e. calling
~CLOSE-SOCKET~ on a server object will /not/ terminate any of its
accepted connections.

The predicate ~CONNECTION-AVAILABLE-P~ returns non ~NIL~ if the server
has connections available.
#+begin_src lisp
(defgeneric connection-available-p (server))
#+end_src

** Stream Sockets
A stream is not a stream until two stream sockets have agreed that
they are able to talk to each other. A stream socket represents one of
the two sockets needed to construct a stream.

There are two ways to create a stream socket, the first is to use a
namespace specific function to initiate a connection to a server. The
second is using the ~ACCEPT-CONNECTION~ function on a server object
when a new connection arrives.

Once a stream socket has been created, it immediately starts to
negotiate with the remote stream socket. This negotiation may take a
significant amount of time, and in some cases may fail to complete for
reasons beyond each socket's control e.g. a network failure, an
overloaded server, a not reachable host. This period of uncertainty is
modelled by the future connection protocol and is implemented by all
stream socket objects.

The future connection protocol is about being informed about the state
of the connection. The non ~NIL~ value of the predicate
#+begin_src lisp
(defgeneric determinedp (future-connection))
#+end_src
 indicates that the operating system has finished trying to negotiate
a new stream connection. The result can be obtained using the
predicates ~CONNECTION-FAILED-P~ and ~CONNECTION-SUCCEEDED-P~.
#+begin_src lisp
(defgeneric connection-failed-p (future-connection))
(defgeneric connection-succeeded-p (future-connection))
#+end_src

If the connection is successful, the stream protocol outlined in the
next section can be used on the socket object to send and receive data
over the newly created stream.

** Streams
The stream protocol represents a communication channel between two
processes. The protocol provides functions for reading and sending
data, as well as querying the current state of the connection.

The function ~DATA-AVAILABLE-P~ can be used to determine if there is
data that can be read immediately from the stream using the function
~READ-FROM-STREAM~.
#+begin_src lisp
(defgeneric data-available-p (stream))
(defgeneric read-from-stream (stream buffer &key start end))
#+end_src
The return value of ~READ-FROM-STREAM~ is the number of bytes written
to ~BUFFER~. This can be either the number of bytes that are
immediately available for reading or the value ~(- END START)~. Note
that it is possible for ~READ-FROM-STREAM~ to signal an error despite
~DATA-AVAILABLE-P~ having returned true! This is the nature of
communication channels where the path connecting the two stream
sockets is governed by a large number of interacting agents.

Writing data to the stream is performed using the function
~WRITE-TO-STREAM~.
#+begin_src lisp
(defgeneric write-to-stream (stream buffer &key start end))
#+end_src
This function will queue the data in ~BUFFER~ and schedule it for
writing once all other data in the queue has been written. Please note
that the function will not block the application. The predicate
~READY-TO-WRITE-P~ can be used to determine if the data will be
written immediately or will be queued.
#+begin_src lisp
(defgeneric ready-to-write-p (stream))
#+end_src
Please be aware that the function ~WRITE-TO-STREAM~ can still fail
even if ~READY-TO-WRITE-P~ returned non ~NIL~.

Last but not least, the predicate ~REMOTE-DISCONNECTED-P~ can be used
to determine if the connection between the two stream socket has been
severed.
#+begin_src lisp
(defgeneric remote-disconnected-p (stream))
#+end_src

* IPv4
The function ~MAKE-IPV4-TCP-SERVER~ creates an IPV4 TCP/IP server that
listens for connections to ~PORT~ on the host ~ADDRESS~. 
#+begin_src lisp
(defun make-ipv4-tcp-server (host-address port &key reuse-socket-address backlog))
#+end_src
The number ~PORT~ must be of type ~(UNSIGNED-BYTE 16)~. The value of
~HOST-ADDRESS~ can be a string in dotted-quad format. e.g ~127.0.0.1~
or one of the constants:
- ~+IPV4-LOOPBACK+~ :: The address of the localhost network interface.
- ~+IPV4-ANY+~ :: All network interfaces for the host.

The value returned from ~MAKE-IPV4-TCP-SERVER~ adheres to the stream
server protocol.

The object returned by ~MAKE-IPV4-TCP-SERVER~ implements the following
functions
- ~HOST-ADDRESS~ :: Obtain the host address component of the socket
                    address the server is using.
- ~PORT~ :: Obtain the port component of the socket address the server
            is using.

The function ~CONNECT-TO-IPV4-TCP-SERVER~ establishes a connection to
a IPv4 TCP server.
#+begin_src lisp
(defun connect-to-ipv4-tcp-server (host-address port))
#+end_src
The pair ~PORT~ and ~HOST-ADDRESS~ represent the port number and host
name of the server to connect to. The value returned adheres to the
future connection protocol.

Streams created from IPV4 TCP socket objects extend the stream
protocol with the following functions
- ~REMOTE-HOST-ADDRESS~ :: The host address component of the socket
     address used by the remote end of the stream.
- ~REMOTE-PORT~ :: The port number component of the socket address
                   used by the remote end of the stream.
- ~LOCAL-HOST-ADDRESS~ :: The host address used to communicate with
     the remote client.
- ~LOCAL-PORT~ :: The port number used to communicate to the remote
                  client.

* Local
This section outlines how to create a communication channel between
two processes running on the same physical machine. 

* Polling
All functions outlined above work directly on the current state of the
socket. The function ~POLL-SOCKET~ allows an application to block
until an object changes state. e.g. data is now available or the
remote host has disconnected.
#+begin_src lisp
(defgeneric poll-socket (socket socket-events timeout))
#+end_src
The ~TIMEOUT~ argument specifies how long to wait (in seconds) until a
state changes occurs on the socket. A value of ~:IMMEDIATE~ indicates
that ~POLL-SOCKET~ should not wait and return the current state. A value of
~:INDEFINITE~ means to wait until an event occurs.

The ~SOCKET-EVENTS~ argument tells the ~POLL-SOCKET~ function what to
wait for. This argument is socket specific and can be either a symbol
or a list of symbols. The symbols accepted correspond to the predicate
functions for each socket object. For example, for stream server
objects, only the symbol ~CONNECTION-AVAILABLE-P~ is accepted. For
future-connection objects, the symbol ~DETERMINEDP~ is permitted and
for streams the list of valid symbols is ~DATA-AVAILABLE-P~,
~READY-TO-WRITE-P~ and ~REMOTE-DISCONNECTED-P~.

The return value of ~POLL-SOCKET~ is either ~SOCKET~ or ~NIL~. A value of
~NIL~ indicates that no events have occurred on the socket and the
~POLL~ timer expired.

An extremely useful variant of ~POLL-SOCKET~ is the ~POLL-SOCKETS~
function.
#+begin_src lisp
(defun poll-sockets (all-sockets all-sockets-events timeout))
#+end_src
This function waits for an event to occur on any one of the sockets
passed in with ~ALL-SOCKETS~. The argument ~ALL-SOCKETS-EVENTS~ is a
list of events that are suitable for the ~POLL-SOCKET~ function. The
value of ~TIMEOUT~ is exactly the same as used in ~POLL-SOCKET~. The
return value is a list that has the same length as ~ALL-SOCKETS~ and
contains either the socket object at the same position in
~ALL-SOCKETS~ or ~NIL~. A ~NIL~ value indicates that no change in
state has occurred.
